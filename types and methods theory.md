# Краткий конспект по видам и направлениям тестирования


## Классификация тестирования по уровню детализации

### Модульное

  Модульное (компонентное) тестирование (unit testing, module testing, component testing) направлено на проверку отдельных небольших частей при-
ложения, которые (как правило) можно исследовать изолированно от других
подобных частей. При выполнении данного тестирования могут проверяться
отдельные функции или методы классов, сами классы, взаимодействие классов, небольшие библиотеки, отдельные части приложения. Часто данный
вид тестирования реализуется с использованием специальных технологий и
инструментальных средств автоматизации тестирования, значительно
упрощающих и ускоряющих разработку соответствующих тест-кейсов.

### Интеграционное тестирование

  Интеграционное тестирование (integration testing, component integration
testing, pairwise integration testing, system integration testing, incremental
testing, interface testing, thread testing) направлено на проверку взаимо-
действия между несколькими частями приложения (каждая из которых, в
свою очередь, проверена отдельно на стадии модульного тестирования). К
сожалению, даже если мы работаем с очень качественными отдельными
компонентами, «на стыке» их взаимодействия часто возникают проблемы.
Именно эти проблемы и выявляет интеграционное тестирование.

### Системное тестирование

  Системное тестирование (system testing) направлено на проверку всего
приложения как единого целого, собранного из частей, проверенных на двух
предыдущих стадиях. Здесь не только выявляются дефекты «на стыках»
компонентов, но и появляется возможность полноценно взаимодействовать
с приложением с точки зрения конечного пользователя, применяя множество
других видов тестирования.

[Подробнее](http://tryqa.com/what-are-software-testing-levels/ )



## Классификация по доступу к коду и архитектуре приложения

### Метод белого ящика

  Метод белого ящика (white box testing, open box testing, clear box testing,
glass box testing) — у тестировщика есть доступ к внутренней структуре и коду
приложения, а также есть достаточно знаний для понимания увиденного. Выделяют даже сопутствующую тестированию по методу белого ящика 
глобальную технику — тестирование на основе дизайна (design-based testing).
Для более глубокого изучения сути метода белого ящика рекомендуется
ознакомиться с техниками исследования потока управления или потока
данных, использования диаграмм состояний. Некоторые авторы склонны
жёстко связывать этот метод со статическим тестированием, но ничто не мешает тестировщику запустить код на выполнение и при этом периодически
обращаться к самому коду (а модульное тестирование и вовсе предполагает запуск кода на исполнение и при этом работу именно с кодом, а не с
«приложением целиком»).

#### Преимущества 

* Показывает скрытые проблемы и
упрощает их диагностику.
* Допускает достаточно простую автоматизацию тест-кейсов и их выполнение на самых ранних стадиях развития проекта.
* Обладает развитой системой метрик, сбор и анализ которых легко
автоматизируется.
* Стимулирует разработчиков к
написанию качественного кода.
* Многие техники этого метода являются проверенными, хорошо
себя зарекомендовавшими решениями, базирующимися на строгом
техническом подходе.

#### Недостатки

* Не может выполняться тестировщиками, не обладающими достаточными знаниями в области программирования.
* Тестирование сфокусировано на
реализованной функциональности, что повышает вероятность
пропуска нереализованных требований.
* Поведение приложения исследуется в отрыве от реальной среды
выполнения и не учитывает её
влияние.
* Поведение приложения исследуется в отрыве от реальных пользовательских сценариев.

### Метод чёрного ящика

Метод чёрного ящика (black box testing, closed box testing, specification-
based testing) — у тестировщика либо нет доступа к внутренней структуре и
коду приложения, либо недостаточно знаний для их понимания, либо он сознательно не обращается к ним в процессе тестирования. При этом абсолютное большинство  видов тестирования работают по методу чёрного ящика, идею которого в альтернативном
определении можно сформулировать так: тестировщик оказывает на приложение воздействия (и проверяет реакцию) тем же способом, каким при реальной эксплуатации приложения на него воздействовали бы пользователи
или другие приложения. В рамках тестирования по методу чёрного ящика основной информацией для создания тест-кейсов выступает документация
(особенно — требования (requirements-based testing)) и общий здравый
смысл (для случаев, когда поведение приложения в некоторой ситуации не
регламентировано явно; иногда это называют «тестированием на основе неявных требований», но канонического определения у этого подхода нет).

#### Преимущества 

* Тестировщик не обязан обладать
(глубокими) знаниями в области
программирования.
* Поведение приложения исследуется в контексте реальной среды
выполнения и учитывает её влияние.
* Поведение приложения исследуется в контексте реальных пользовательских сценариев.
* Тест-кейсы можно создавать уже
на стадии появления стабильных
требований.
* Процесс создания тест-кейсов позволяет выявить дефекты в требованиях.
* Допускает создание тест-кейсов,
которые можно многократно использовать на разных проектах.

#### Недостатки

* Возможно повторение части тест-
кейсов, уже выполненных разработчиками.
* Высока вероятность того, что
часть возможных вариантов поведения приложения останется не-
протестированной.
* Для разработки высокоэффективных тест-кейсов необходима качественная документация.
* Диагностика обнаруженных дефектов более сложна в сравнении
с техниками метода белого ящика.
* В связи с широким выбором техник и подходов затрудняется планирование и оценка трудозатрат.
* В случае автоматизации могут потребоваться сложные дорогостоящие инструментальные средства.

### Метод серого ящика

Метод серого ящика (gray box testing) — комбинация методов белого
ящика и чёрного ящика, состоящая в том, что к части кода и архитектуры у
тестировщика доступ есть, а к части — нет. Eго явное
упоминание — крайне редкий случай: обычно говорят о методах белого или
чёрного ящика в применении к тем или иным частям приложения, при этом
понимая, что «приложение целиком» тестируется по методу серого ящика.

Сочетает преимущества и недостатки методов белого и чёрного ящика.



## Классификация по запуску кода на исполнение

Далеко не всякое тестирование предполагает взаимодействие с работаю-
щим приложением. Потому в рамках данной классификации выделяют:

### Статическое тестирование

Статическое тестирование (static testing) — тестирование без запуска
кода на исполнение. В рамках этого подхода тестированию могут подвергаться:
* Документы (требования, тест-кейсы, описания архитектуры приложения, схемы баз данных и т.д.).
* Графические прототипы (например, эскизы пользовательского интерфейса).
* Код приложения (что часто выполняется самими программистами в
рамках аудита кода (code review), являющегося специфической вариацией взаимного просмотра в применении к исходному коду). Код
приложения также можно проверять с использованием техник тестирования на основе структур кода.
* Параметры (настройки) среды исполнения приложения.
* Подготовленные тестовые данные.

### Динамическое тестирование

Динамическое тестирование (dynamic testing) — тестирование с запуском
кода на исполнение. Запускаться на исполнение может как код всего приложения целиком (системное тестирование), так и код нескольких взаимосвязанных частей (интеграционное тестирование), отдельных частей (модульное или компонентное тестирование) и даже отдельные участки кода. Основная идея этого вида тестирования состоит в том, что проверяется реальное поведение (части) приложения.




## Классификация по (убыванию) степени важности тестируемых функций (по уровню функционального тестирования)

В некоторых источниках эту разновидность классификации также называют
«по глубине тестирования».

Возможна путаница, вызванная тем, что единого общепринятого набора классификаций не существует, и две из них имеют очень схожие названия:
* «По уровню детализации приложения» = «по уровню тестирования».
* «По (убыванию) степени важности тестируемых функций» = «по
уровню функционального тестирования».

![img](scr1.png "Виды")

### Дымовое тестирование

Дымовое тестирование (smoke test, intake test, build verification test)
направлено на проверку самой главной, самой важной, самой ключевой
функциональности, неработоспособность которой делает бессмысленной
саму идею использования приложения (или иного объекта, подвергаемого
дымовому тестированию).

Дымовое тестирование проводится после выхода нового билда, чтобы определить общий уровень качества приложения и принять решение о (не)целесообразности выполнения тестирования критического пути и расширенного
тестирования. Поскольку тест-кейсов на уровне дымового тестирования относительно немного, а сами они достаточно просты, но при этом очень часто
повторяются, они являются хорошими кандидатами на автоматизацию. В
связи с высокой важностью тест-кейсов на данном уровне пороговое значение метрики их прохождения часто выставляется равным 100 % или близким
к 100 %

### Тестирование критического пути

Тестирование критического пути (critical path test) направлено на исследование функциональности, используемой типичными пользователями в типичной повседневной деятельности. Cама идея позаимствована из управления проектами и трансформирована в контексте тестирования в следующую: существует большинство пользователей, которые чаще всего используют некое
подмножество функций приложения. Именно эти функции
и нужно проверить, как только мы убедились, что приложение «в принципе
работает» (дымовой тест прошёл успешно). Если по каким-то причинам приложение не выполняет эти функции или выполняет их некорректно, очень
многие пользователи не смогут достичь множества своих целей. Пороговое
значение метрики успешного прохождения «теста критического пути» уже немного ниже, чем в дымовом тестировании, но всё равно достаточно высоко
(как правило, порядка 70–80–90 % — в зависимости от сути проекта).

### Расширенное тестирование

Расширенное тестирование (extended test) направлено на исследование
всей заявленной в требованиях функциональности — даже той, которая
низко проранжирована по степени важности. При этом здесь также учитывается, какая функциональность является более важной, а какая — менее важной. Но при наличии достаточного количества времени и иных ресурсов тест-кейсы этого уровня могут затронуть даже самые низкоприоритетные требования.
Ещё одним направлением исследования в рамках данного тестирования являются нетипичные, маловероятные, экзотические случаи и сценарии использования функций и свойств приложения, затронутых на предыдущих
уровнях. Пороговое значение метрики успешного прохождения расширенного тестирования существенно ниже, чем в тестировании критического пути
(иногда можно увидеть даже значения в диапазоне 30–50 %, т.к. подавляю-
щее большинство найденных здесь дефектов не представляет угрозы для
успешного использования приложения большинством пользователей).

### Регрессионное тестирование

Регрессионное тестирование (regression testing) — тестирование,
направленное на проверку того факта, что в ранее работоспособной функциональности не появились ошибки, вызванные изменениями в приложении
или среде его функционирования. Фредерик Брукс в своей книге «Мифический человеко-месяц»166 писал: «Фундаментальная проблема при сопровождении программ состоит в том, что исправление одной ошибки с большой
вероятностью (20–50 %) влечёт появление новой». Потому регрессионное
тестирование является неотъемлемым инструментом обеспечения качества
и активно используется практически в любом проекте.

### Повторное тестирование

Повторное тестирование (re-testing, confirmation testing) — выполнение
тест-кейсов, которые ранее обнаружили дефекты, с целью подтверждения
устранения дефектов. Фактически этот вид тестирования сводится к действиям на финальной стадии жизненного цикла отчёта о дефекте, направленным на то, чтобы перевести дефект в состояние «проверен» и «закрыт».



## Классификация по степени автоматизации

### Ручное тестирование

Ручное тестирование (manual testing) — тестирование, в котором тест-
кейсы выполняются человеком вручную без использования средств автома-
тизации. Несмотря на то что это звучит очень просто, от тестировщика в те
или иные моменты времени требуются такие качества, как терпеливость,
наблюдательность, креативность, умение ставить нестандартные эксперименты, а также умение видеть и понимать, что происходит «внутри системы»,
т.е. как внешние воздействия на приложение трансформируются в его внутренние процессы.

### Автоматизированное тестирование

Автоматизированное тестирование (automated testing, test automation) —
набор техник, подходов и инструментальных средств, позволяющий исключить человека из выполнения некоторых задач в процессе тестирования.
Тест-кейсы частично или полностью выполняет специальное инструментальное средство, однако разработка тест-кейсов, подготовка данных, оценка ре-
зультатов выполнения, написания отчётов об обнаруженных дефектах — всё
это и многое другое по-прежнему делает человек.

Если же выразить все преимущества и недостатки автоматизации тестирования одной фразой, то получается, что автоматизация позволяет ощутимо увели-
чить тестовое покрытие (test coverage), но при этом столь же ощутимо увеличивает риски.




## Классификация по принципам работы с приложением

### Позитивное тестирование

Позитивное тестирование (positive testing) направлено на исследование
приложения в ситуации, когда все действия выполняются строго по инструкции без каких бы то ни было ошибок, отклонений, ввода неверных данных и
т.д. Если позитивные тест-кейсы завершаются ошибками, это тревожный
признак — приложение работает неверно даже в идеальных условиях (и
можно предположить, что в неидеальных условиях оно работает ещё хуже).
Для ускорения тестирования несколько позитивных тест-кейсов можно объединять (например, перед отправкой заполнить все поля формы верными
значениями) — иногда это может усложнить диагностику ошибки, но существенная экономия времени компенсирует этот риск.

### Негативное тестирование

Негативное тестирование (negative testing, invalid testing) — направлено
на исследование работы приложения в ситуациях, когда с ним выполняются
(некорректные) операции и/или используются данные, потенциально приводящие к ошибкам (классика жанра — деление на ноль). Поскольку в реальной жизни таких ситуаций значительно больше (пользователи допускают
ошибки, злоумышленники осознанно «ломают» приложение, в среде работы
приложения возникают проблемы и т.д.), негативных тест-кейсов оказывается значительно больше, чем позитивных (иногда — в разы или даже на
порядки). В отличие от позитивных негативные тест-кейсы не стоит объединять, т.к. подобное решение может привести к неверной трактовке поведения
приложения и пропуску (необнаружению) дефектов.

